spring:
    #    h2:
    #        console:
    #            enabled: true
    #    datasource:
    #        url: jdbc:h2:mem:test
    #    jpa:
    #        show-sql: true
    #        hibernate:
    #            ddl-auto: create
    datasource:
        url: jdbc:postgresql://postgres_container:5432/order
        username: malcolm
        password: malcolm

#    rabbitmq:
#        host: ${RABBITMQ_HOST:localhost}
#        port: ${RABBITMQ_PORT:5672}
#        username: ${RABBITMQ_USERNAME:guest}
#        password: ${RABBITMQ_PASSWORD:guest}
#        virtual-host: ${RABBITMQ_VHOST:guest}
#        connection-timeout: 30000

    cloud:
        stream:
            bindings:
                createOrder-out-0:
                    destination: order.exchange
                    content-type: application/json
            kafka:
                binder:
                    brokers: kafka:9092
    #            rabbit:
    #                bindings:
    #                    createOrder-out-0:
    #                        producer:
    #                            routing-key-expression: "'order.tracking'"

    #rabbitmq:
    #    exchange:
    #        name: order.exchange
    #    queue:
    #        name: order.queue
    #    routing:
    #        key: order.tracking

    jpa:
        database: POSTGRESQL
        show-sql: true
        hibernate:
            ddl-auto: update
        database-platform: org.hibernate.dialect.PostgreSQLDialect

eureka:
    instance:
        prefer-ip-address: true # When this service tries to make a call to a service registered on eureka, it will use the IP address stored on Eureka instead of the hostname.
    client:
        service-url:
            default-zone: http://eureka:8761/eureka
        register-with-eureka: true
        fetch-registry: true

management:
    endpoints:
        web:
            exposure:
                include: "*"
    endpoint:
        shutdown:
            access: unrestricted
        health:
            show-details: always
    health:
        circuitbreakers:
            enabled: true
    tracing:
        sampling:
            probability: 1.0

# Circuit Breaker. You can find properties at https://resilience4j.readme.io/docs/circuitbreaker#create-and-configure-a-circuitbreaker
resilience4j:
    circuitbreaker:
        instances:
            product:
                registerHealthIndicator: true
                slidingWindowSize: 10
                minimumNumberOfCalls: 5
                permittedNumberOfCallsInHalfOpenState: 3
                waitDurationInOpenState: 10s
                failureRateThreshold: 50
                automaticTransitionFromOpenToHalfOpenEnabled: true
                slidingWindowType: count_based
    retry:
        instances:
            retryBreaker:
                maxAttempts: 5
                waitDuration: 500ms
    ratelimiter:
        instances:
            rateBreaker:
                timeout-duration: 0
                limit-refresh-period: 4s
                limit-for-period: 2

logging:
    level:
        root: INFO
        com.malcolm.user: INFO
    file:
        name: ../logs/${spring.application.name}.log
    logback:
        rollingpolicy:
            max-file-size: 5MB
            max-history: 7

app:
    message: "Hello Order!"

server:
    port: 8083
